<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>algorithms on Gradient IIITS</title>
    <link>http://gradient-iiits.github.io/tags/algorithms/</link>
    <description>Recent content in algorithms on Gradient IIITS</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 17 May 2020 18:06:28 +0530</lastBuildDate>
    
	<atom:link href="http://gradient-iiits.github.io/tags/algorithms/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Sparse Table</title>
      <link>http://gradient-iiits.github.io/posts/sparse-table/</link>
      <pubDate>Sun, 17 May 2020 18:06:28 +0530</pubDate>
      
      <guid>http://gradient-iiits.github.io/posts/sparse-table/</guid>
      <description>Sparse Table Sparse Table is a data structure that lets you answer, most range queries in $\mathcal{O}(\log{n})$, in an immutable array. But for some queries like (minimum, maximum, gcd) it can answer queries in $\mathcal{O}(1)$. It also requires $\mathcal{O}(n\log{n})$ preprocessing time and extra space of similar order. One thing to note is that you cannot change the elements of the array, therefore this algorithm might be useful only when values of array remain unchanged.</description>
    </item>
    
    <item>
      <title>Square Root Decomposition</title>
      <link>http://gradient-iiits.github.io/posts/sqrt-decomposition/</link>
      <pubDate>Tue, 05 May 2020 20:56:37 +0530</pubDate>
      
      <guid>http://gradient-iiits.github.io/posts/sqrt-decomposition/</guid>
      <description>Square Root Decomposition Square Root Decomposition is an algorithm for answering range queries, in $\mathcal{O}(Q\sqrt{N})$, where $Q$ is the number of queries and $N$ is the number of elements in the range. It is very useful in a lot of CP questions. The basic technique of Square Root Decomposition can be used for doing certain queries on Trees as well.
Motivation Let us look at a problem, to motivate the need for this algorithm.</description>
    </item>
    
  </channel>
</rss>