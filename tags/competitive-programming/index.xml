<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>competitive-programming on Gradient IIITS</title>
    <link>http://gradient-iiits.github.io/tags/competitive-programming/</link>
    <description>Recent content in competitive-programming on Gradient IIITS</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 17 May 2020 18:06:28 +0530</lastBuildDate>
    
	<atom:link href="http://gradient-iiits.github.io/tags/competitive-programming/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Sparse Table</title>
      <link>http://gradient-iiits.github.io/posts/sparse-table/</link>
      <pubDate>Sun, 17 May 2020 18:06:28 +0530</pubDate>
      
      <guid>http://gradient-iiits.github.io/posts/sparse-table/</guid>
      <description>Sparse Table Sparse Table is a data structure that lets you answer, most range queries in $\mathcal{O}(\log{n})$, in an immutable array. But for some queries like (minimum, maximum, gcd) it can answer queries in $\mathcal{O}(1)$. It also requires $\mathcal{O}(n\log{n})$ preprocessing time and extra space of similar order. One thing to note is that you cannot change the elements of the array, therefore this algorithm might be useful only when values of array remain unchanged.</description>
    </item>
    
    <item>
      <title>Square Root Decomposition</title>
      <link>http://gradient-iiits.github.io/posts/sqrt-decomposition/</link>
      <pubDate>Tue, 05 May 2020 20:56:37 +0530</pubDate>
      
      <guid>http://gradient-iiits.github.io/posts/sqrt-decomposition/</guid>
      <description>Square Root Decomposition Square Root Decomposition is an algorithm for answering range queries, in $\mathcal{O}(Q\sqrt{N})$, where $Q$ is the number of queries and $N$ is the number of elements in the range. It is very useful in a lot of CP questions. The basic technique of Square Root Decomposition can be used for doing certain queries on Trees as well.
Motivation Let us look at a problem, to motivate the need for this algorithm.</description>
    </item>
    
    <item>
      <title>Competitive Programming - How do I Start ?</title>
      <link>http://gradient-iiits.github.io/posts/competitive-programming-how-do-i-start/</link>
      <pubDate>Sun, 20 Jan 2019 00:18:16 +0530</pubDate>
      
      <guid>http://gradient-iiits.github.io/posts/competitive-programming-how-do-i-start/</guid>
      <description>A lot of enthusiastic beginners are often intimidated by the huge amount of topics in CP and the amount of OJâ€™s on the web. As a result, due to lack of guidance they are let down ,take up inefficient learning methods and end up getting frustrated. This article aims to guide beginners on how to start your journey into the world of competitive programming.
These are the brief areas I wish to cover in this article:</description>
    </item>
    
  </channel>
</rss>